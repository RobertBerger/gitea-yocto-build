name: release
#on: [push]
on:
  push:
    branches: [ "langdale" ]
  workflow_dispatch:
jobs:
  release:
    # runs-on: yocto-build-latest
    # runs-on: 2023-05-24-master-local-icecc-ub20-doc-action
    runs-on: yocto-build-langdale
    steps:
      - name: Get build system info
        id: build_system
        run: |
          echo "Host: ${HOSTNAME}"
          echo "CPUs/Threads: $(grep -c ^processor /proc/cpuinfo)"
          echo "CPUs: $(grep ^cpu\\scores /proc/cpuinfo | uniq |  awk '{print $4}')"
          echo "$(free -mh)"
  call-runall-fetch:
    # get all the sources from outside
    #   - we use premirros in order to speed up checking out kernel, u-boot,...
    #     - because of this we need a hack (symlink) from original to mirror
    #     - e.g. gitshallow_git.kernel.org.pub.scm.linux.kernel.git.stable.linux-stable.git_ebdb69c-1_linux-6.1.y.tar.gz -> gitshallow_10.0.0.182.8939.robert.berger.linux-stable.git_ebdb69c-1_linux-6.1.y.tar.gz
    # source mirrors (tarball for local, network source-mirror) are populated
    # (networked accessible) PR_SERVER is active
    # (networked accessible) HASH_SERVER is active
    #
    # bitbake uninative-tarball --runall=fetch
    # bitbake core-image-minimal --runall=fetch  
    uses: ./.gitea/workflows/01-uninative-core-image-minimal-prep-runall-fetch.yml
    secrets: inherit
  call-uninative-from-local-source-mirror:
    # BB_NO_NETWORK is active
    # get all the sources from a local source-mirror
    #   - download tarball from web server and unpack it
    # (networked accessible) PR_SERVER is active
    # (networked accessible) HASH_SERVER is active
    # 
    # bitbake uninative-tarball
    # bitbake core-image-minimal 
    #   - just to see that we can build it from the local source mirror
    #   - if we would populate the sstate-mirror we would achive 
    #     Sstate summary: Wanted 868 Local 0 Mirrors 487 Missed 381 Current 0 (56% match, 0% complete)
    #     and not
    #     Sstate summary: Wanted 868 Local 0 Mirrors 864 Missed 4 Current 0 (99% match, 0% complete)
    #
    # populate uninative tarball
    #   - we create a file with the sha256sum of it
    #   - we create a symlink for it 
    #if: ${{ always() }} #This will make your workflow2 executed even if workflow1 fails, remove this, if you want to run this only on success of workflow1
    needs: call-runall-fetch
    uses: ./.gitea/workflows/02-uninative-local-source-mirror.yml
    secrets: inherit
  call-use-uninative-core-image-minimal-local-source-mirror:
    needs: call-uninative-from-local-source-mirror
    uses: ./.gitea/workflows/03-use-uninative-core-image-minimal-local-source-mirror.yml
    secrets: inherit
  call-use-uninative-core-image-minimal-populate-sstate-mirror:
    # get/use the uninative tarball from an internal web server
    # get all sources from a network accessible source-mirror
    #   - I would think that local source-mirror would be faster
    #   - use premirrors
    # (networked accessible) PR_SERVER is active
    # (networked accessible) HASH_SERVER is active
    #
    # bitbake core-image-minimal
    #
    # populate (network accessible) sstate-mirror   
    # now we should have a 99% Sstate match 
    #
    needs: call-use-uninative-core-image-minimal-local-source-mirror
    uses: ./.gitea/workflows/04-use-uninative-core-image-minimal-populate-sstate-mirror.yml
    secrets: inherit
